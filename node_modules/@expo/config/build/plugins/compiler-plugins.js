"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const plist_1 = __importDefault(require("@expo/plist"));
const fs_extra_1 = require("fs-extra");
const path_1 = __importDefault(require("path"));
const WarningAggregator_1 = require("../WarningAggregator");
const Entitlements_1 = require("../ios/Entitlements");
const Xcodeproj_1 = require("../ios/utils/Xcodeproj");
const core_plugins_1 = require("./core-plugins");
function withCoreMods(config, projectRoot) {
    config = applyIOSCoreMods(projectRoot, config);
    config = applyAndroidCoreMods(projectRoot, config);
    return config;
}
exports.withCoreMods = withCoreMods;
function resolveModResults(results, platformName, modName) {
    // If the results came from a mod, they'd be in the form of [config, data].
    // Ensure the results are an array and omit the data since it should've been written by a data provider plugin.
    const ensuredResults = results;
    // Sanity check to help locate non compliant mods.
    if (!ensuredResults || typeof ensuredResults !== 'object' || !(ensuredResults === null || ensuredResults === void 0 ? void 0 : ensuredResults.mods)) {
        throw new Error(`Mod \`mods.${platformName}.${modName}\` evaluated to an object that is not a valid project config. Instead got: ${JSON.stringify(ensuredResults)}`);
    }
    return ensuredResults;
}
exports.resolveModResults = resolveModResults;
function applyAndroidCoreMods(projectRoot, config) {
    // TODO: Support android mods
    return config;
}
function applyIOSCoreMods(projectRoot, config) {
    const { iosProjectDirectory, supportingDirectory } = getIOSPaths(projectRoot, config);
    // Append a rule to supply Info.plist data to mods on `mods.ios.infoPlist`
    config = core_plugins_1.withInterceptedMod(config, {
        platform: 'ios',
        mod: 'infoPlist',
        async action(_a) {
            var _b = _a.modRequest, { nextMod } = _b, modRequest = __rest(_b, ["nextMod"]), config = __rest(_a, ["modRequest"]);
            let results = Object.assign(Object.assign({}, config), { modRequest });
            // Apply all of the Info.plist values to the expo.ios.infoPlist object
            // TODO: Remove this in favor of just overwriting the Info.plist with the Expo object. This will enable people to actually remove values.
            if (!config.ios) {
                config.ios = {};
            }
            if (!config.ios.infoPlist) {
                config.ios.infoPlist = {};
            }
            const filePath = path_1.default.resolve(iosProjectDirectory, 'Info.plist');
            let data = plist_1.default.parse(await fs_extra_1.readFile(filePath, 'utf8'));
            config.ios.infoPlist = Object.assign(Object.assign({}, (data || {})), config.ios.infoPlist);
            // TODO: Fix type
            results = await nextMod(Object.assign(Object.assign({}, config), { modRequest, modResults: config.ios.infoPlist }));
            resolveModResults(results, modRequest.platform, modRequest.modName);
            data = results.modResults;
            await fs_extra_1.writeFile(filePath, plist_1.default.build(data));
            return results;
        },
    });
    // Append a rule to supply Expo.plist data to mods on `mods.ios.expoPlist`
    config = core_plugins_1.withInterceptedMod(config, {
        platform: 'ios',
        mod: 'expoPlist',
        async action(_a) {
            var _b = _a.modRequest, { nextMod } = _b, modRequest = __rest(_b, ["nextMod"]), config = __rest(_a, ["modRequest"]);
            let results = Object.assign(Object.assign({}, config), { modRequest });
            try {
                const filePath = path_1.default.resolve(supportingDirectory, 'Expo.plist');
                let modResults = plist_1.default.parse(await fs_extra_1.readFile(filePath, 'utf8'));
                // TODO: Fix type
                results = await nextMod(Object.assign(Object.assign({}, config), { modResults,
                    modRequest }));
                resolveModResults(results, modRequest.platform, modRequest.modName);
                modResults = results.modResults;
                await fs_extra_1.writeFile(filePath, plist_1.default.build(modResults));
            }
            catch (error) {
                WarningAggregator_1.addWarningIOS('updates', 'Expo.plist configuration could not be applied. You will need to create Expo.plist if it does not exist and add Updates configuration manually.', 'https://docs.expo.io/bare/updating-your-app/#configuration-options');
            }
            return results;
        },
    });
    // Append a rule to supply .xcodeproj data to mods on `mods.ios.xcodeproj`
    config = core_plugins_1.withInterceptedMod(config, {
        platform: 'ios',
        mod: 'xcodeproj',
        async action(_a) {
            var _b = _a.modRequest, { nextMod } = _b, modRequest = __rest(_b, ["nextMod"]), config = __rest(_a, ["modRequest"]);
            const modResults = Xcodeproj_1.getPbxproj(projectRoot);
            // TODO: Fix type
            const results = await nextMod(Object.assign(Object.assign({}, config), { modResults,
                modRequest }));
            resolveModResults(results, modRequest.platform, modRequest.modName);
            const resultData = results.modResults;
            await fs_extra_1.writeFile(resultData.filepath, resultData.writeSync());
            return results;
        },
    });
    config = withEntitlementsBaseMod(config);
    return config;
}
const withEntitlementsBaseMod = config => {
    // Append a rule to supply .entitlements data to mods on `mods.ios.entitlements`
    return core_plugins_1.withInterceptedMod(config, {
        platform: 'ios',
        mod: 'entitlements',
        async action(_a) {
            var _b = _a.modRequest, { nextMod } = _b, modRequest = __rest(_b, ["nextMod"]), config = __rest(_a, ["modRequest"]);
            const entitlementsPath = Entitlements_1.getEntitlementsPath(modRequest.projectRoot);
            let results = Object.assign(Object.assign({}, config), { modRequest });
            try {
                const data = plist_1.default.parse(await fs_extra_1.readFile(entitlementsPath, 'utf8'));
                // Apply all of the .entitlements values to the expo.ios.entitlements object
                // TODO: Remove this in favor of just overwriting the .entitlements with the Expo object. This will enable people to actually remove values.
                if (!config.ios) {
                    config.ios = {};
                }
                if (!config.ios.entitlements) {
                    config.ios.entitlements = {};
                }
                config.ios.entitlements = Object.assign(Object.assign({}, (data || {})), config.ios.entitlements);
                // TODO: Fix type
                results = await nextMod(Object.assign(Object.assign({}, config), { modRequest, modResults: config.ios.entitlements }));
                resolveModResults(results, modRequest.platform, modRequest.modName);
                await fs_extra_1.writeFile(entitlementsPath, plist_1.default.build(results.modResults));
            }
            catch (error) {
                WarningAggregator_1.addWarningIOS('entitlements', `${entitlementsPath} configuration could not be applied.`);
            }
            return results;
        },
    });
};
// TODO: come up with a better solution for using app.json expo.name in various places
function sanitizedName(name) {
    return name
        .replace(/[\W_]+/g, '')
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '');
}
// TODO: it's silly and kind of fragile that we look at app config to determine
// the ios project paths. Overall this function needs to be revamped, just a
// placeholder for now! Make this more robust when we support applying config
// at any time (currently it's only applied on eject).
function getIOSPaths(projectRoot, exp) {
    let projectName = null;
    // Attempt to get the current ios folder name (apply).
    try {
        projectName = Xcodeproj_1.getProjectName(projectRoot);
    }
    catch (_a) {
        // If no iOS project exists then create a new one (eject).
        projectName = exp.name;
        if (!projectName) {
            throw new Error('Your project needs a name in app.json/app.config.js.');
        }
        projectName = sanitizedName(projectName);
    }
    const iosProjectDirectory = path_1.default.join(projectRoot, 'ios', projectName);
    const iconPath = path_1.default.join(iosProjectDirectory, 'Assets.xcassets', 'AppIcon.appiconset');
    const supportingDirectory = path_1.default.join(iosProjectDirectory, 'Supporting');
    return {
        projectName,
        supportingDirectory,
        iosProjectDirectory,
        iconPath,
    };
}
//# sourceMappingURL=compiler-plugins.js.map