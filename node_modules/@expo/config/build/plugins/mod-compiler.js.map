{"version":3,"file":"mod-compiler.js","sourceRoot":"","sources":["../../src/plugins/mod-compiler.ts"],"names":[],"mappings":";;;;;AAAA,gDAAwB;AAGxB,sDAAwD;AACxD,yDAAqE;AAErE;;;;GAIG;AACI,KAAK,UAAU,gBAAgB,CACpC,MAAsB,EACtB,WAAmB;IAEnB,MAAM,GAAG,+BAAY,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;IAC3C,OAAO,MAAM,aAAa,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;AAClD,CAAC;AAND,4CAMC;AAED;;;;GAIG;AACI,KAAK,UAAU,aAAa,CACjC,MAAsB,EACtB,WAAmB;;IAEnB,KAAK,MAAM,CAAC,YAAY,EAAE,QAAQ,CAAC,IAAI,MAAM,CAAC,OAAO,OAAC,MAAM,CAAC,IAAI,mCAAK,EAAgB,CAAC,EAAE;QACvF,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QACzC,IAAI,OAAO,CAAC,MAAM,EAAE;YAClB,MAAM,mBAAmB,GAAG,cAAI,CAAC,IAAI,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;YACjE,MAAM,WAAW,GAAG,YAAY,KAAK,KAAK,CAAC,CAAC,CAAC,0BAAc,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;YAErF,KAAK,MAAM,CAAC,OAAO,EAAE,GAAG,CAAC,IAAI,OAAO,EAAE;gBACpC,MAAM,UAAU,GAAG;oBACjB,WAAW;oBACX,WAAW;oBACX,mBAAmB;oBACnB,QAAQ,EAAE,YAA2B;oBACrC,OAAO;iBACR,CAAC;gBACF,MAAM,OAAO,GAAG,MAAO,GAAW,iCAC7B,MAAM,KACT,UAAU,EAAE,IAAI,EAChB,UAAU,IACV,CAAC;gBAEH,kDAAkD;gBAClD,MAAM,GAAG,oCAAiB,CAAC,OAAO,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC;gBAC3D,8CAA8C;gBAC9C,OAAO,MAAM,CAAC,UAAU,CAAC;gBACzB,8CAA8C;gBAC9C,OAAO,MAAM,CAAC,UAAU,CAAC;aAC1B;SACF;KACF;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAnCD,sCAmCC","sourcesContent":["import path from 'path';\n\nimport { ExportedConfig, Mod, ModConfig, ModPlatform } from '../Plugin.types';\nimport { getProjectName } from '../ios/utils/Xcodeproj';\nimport { resolveModResults, withCoreMods } from './compiler-plugins';\n\n/**\n *\n * @param projectRoot\n * @param config\n */\nexport async function compileModsAsync(\n  config: ExportedConfig,\n  projectRoot: string\n): Promise<ExportedConfig> {\n  config = withCoreMods(config, projectRoot);\n  return await evalModsAsync(config, projectRoot);\n}\n\n/**\n * A generic plugin compiler.\n *\n * @param config\n */\nexport async function evalModsAsync(\n  config: ExportedConfig,\n  projectRoot: string\n): Promise<ExportedConfig> {\n  for (const [platformName, platform] of Object.entries(config.mods ?? ({} as ModConfig))) {\n    const entries = Object.entries(platform);\n    if (entries.length) {\n      const platformProjectRoot = path.join(projectRoot, platformName);\n      const projectName = platformName === 'ios' ? getProjectName(projectRoot) : undefined;\n\n      for (const [modName, mod] of entries) {\n        const modRequest = {\n          projectRoot,\n          projectName,\n          platformProjectRoot,\n          platform: platformName as ModPlatform,\n          modName,\n        };\n        const results = await (mod as Mod)({\n          ...config,\n          modResults: null,\n          modRequest,\n        });\n\n        // Sanity check to help locate non compliant mods.\n        config = resolveModResults(results, platformName, modName);\n        // @ts-ignore: data is added for modifications\n        delete config.modResults;\n        // @ts-ignore: info is added for modifications\n        delete config.modRequest;\n      }\n    }\n  }\n\n  return config;\n}\n"]}